
import os

class SystemCExporter:
    """
    Generates SystemC / TLM-2.0 Models for the CIM Core.
    This enables Co-Simulation in standard EDA environments (Virtualizer, QEMU-SystemC).
    """
    def __init__(self, output_dir, config):
        self.output_dir = output_dir
        self.config = config # dict e.g. {'mac_size': 256, 'sram_kb': 64}
        
    def generate(self):
        self._generate_header()
        self._generate_implementation()
        print(f"[Success] SystemC Model Generated in {self.output_dir}")

    def _generate_header(self):
        content = f"""/**
 * Hive-Reflex CIM Core - SystemC TLM-2.0 Model
 * Generated by systemc_exporter.py
 */

#ifndef CIM_CORE_H
#define CIM_CORE_H

#include <systemc.h>
#include <tlm.h>
#include <tlm_utils/simple_target_socket.h>

class CIM_Core : public sc_module {{
public:
    // TLM Socket to receive transactions from CPU (RISC-V)
    tlm_utils::simple_target_socket<CIM_Core> socket;

    // Registers
    uint32_t REG_STATUS;
    uint32_t REG_CTRL;
    
    // Config
    static const int MAC_ARRAY_SIZE = {self.config.get('mac_size', 256)};
    static const int SRAM_SIZE_KB = {self.config.get('sram_kb', 64)};

    SC_CTOR(CIM_Core) : socket("socket") {{
        // Register Callbacks
        socket.register_b_transport(this, &CIM_Core::b_transport);
        SC_THREAD(compute_process);
        
        REG_STATUS = 0;
        REG_CTRL = 0;
    }}

private:
    void b_transport(tlm::tlm_generic_payload& trans, sc_time& delay);
    void compute_process();
    
    // Internal Memory (Mock)
    std::vector<uint8_t> sram;
}};

#endif // CIM_CORE_H
"""
        with open(os.path.join(self.output_dir, "cim_core.h"), "w") as f:
            f.write(content)

    def _generate_implementation(self):
        content = f"""/**
 * Hive-Reflex CIM Core - Implementation
 */

#include "cim_core.h"

void CIM_Core::b_transport(tlm::tlm_generic_payload& trans, sc_time& delay) {{
    tlm::tlm_command cmd = trans.get_command();
    uint64_t addr = trans.get_address();
    unsigned char* ptr = trans.get_data_ptr();
    unsigned int len = trans.get_data_length();

    if (cmd == tlm::TLM_WRITE_COMMAND) {{
        // Check for ISA specific addresses or Registers
        if (addr == 0x4000) {{
             // Command Register
             REG_CTRL = *((uint32_t*)ptr);
             // Trigger Compute Event (not shown)
        }}
    }} else if (cmd == tlm::TLM_READ_COMMAND) {{
        // Read Status
        if (addr == 0x4004) {{
             *((uint32_t*)ptr) = REG_STATUS;
        }}
    }}
    
    // Simulate Latency
    delay += sc_time(10, SC_NS);
    
    trans.set_response_status(tlm::TLM_OK_RESPONSE);
}}

void CIM_Core::compute_process() {{
    while(true) {{
        wait(10, SC_NS); 
        // Compute logic would go here
    }}
}}
"""
        with open(os.path.join(self.output_dir, "cim_core.cpp"), "w") as f:
            f.write(content)

# Demo usage
if __name__ == "__main__":
    exporter = SystemCExporter(".", {'mac_size': 512, 'sram_kb': 128})
    exporter.generate()
